/**
* TravelTime Platform API
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* OpenAPI spec version: 1.0.0
* Contact: support@igeolise.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package traveltimeplatform.apis

import traveltimeplatform.models.RequestRoutes
import traveltimeplatform.models.RequestSupportedLocations
import traveltimeplatform.models.RequestTimeFilter
import traveltimeplatform.models.RequestTimeFilterFast
import traveltimeplatform.models.RequestTimeFilterPostcodeDistricts
import traveltimeplatform.models.RequestTimeFilterPostcodeSectors
import traveltimeplatform.models.RequestTimeFilterPostcodes
import traveltimeplatform.models.RequestTimeMap
import traveltimeplatform.models.ResponseError
import traveltimeplatform.models.ResponseGeocoding
import traveltimeplatform.models.ResponseMapInfo
import traveltimeplatform.models.ResponseRoutes
import traveltimeplatform.models.ResponseSupportedLocations
import traveltimeplatform.models.ResponseTimeFilter
import traveltimeplatform.models.ResponseTimeFilterFast
import traveltimeplatform.models.ResponseTimeFilterPostcodeDistricts
import traveltimeplatform.models.ResponseTimeFilterPostcodeSectors
import traveltimeplatform.models.ResponseTimeFilterPostcodes
import traveltimeplatform.models.ResponseTimeMap

import traveltimeplatform.infrastructure.*

class DefaultApi(basePath: kotlin.String = "https://api.traveltimeapp.com") : ApiClient(basePath) {

    /**
    * 
    * 
    * @param focusLat  
    * @param focusLng  
    * @param withinCountry  (optional, default to null)
    * @return ResponseGeocoding
    */
    @Suppress("UNCHECKED_CAST")
    fun geocodingReverseSearch(focusLat: kotlin.Double, focusLng: kotlin.Double, withinCountry: kotlin.String) : ResponseGeocoding {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("focus.lat" to listOf("$focusLat"), "focus.lng" to listOf("$focusLng"), "within.country" to listOf("$withinCountry"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v4/geocoding/reverse",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseGeocoding>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseGeocoding
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param query  
    * @param withinCountry  (optional, default to null)
    * @param focusLat  (optional, default to null)
    * @param focusLng  (optional, default to null)
    * @return ResponseGeocoding
    */
    @Suppress("UNCHECKED_CAST")
    fun geocodingSearch(query: kotlin.String, withinCountry: kotlin.String, focusLat: kotlin.Double, focusLng: kotlin.Double) : ResponseGeocoding {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("query" to listOf("$query"), "within.country" to listOf("$withinCountry"), "focus.lat" to listOf("$focusLat"), "focus.lng" to listOf("$focusLng"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v4/geocoding/search",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseGeocoding>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseGeocoding
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @return ResponseMapInfo
    */
    @Suppress("UNCHECKED_CAST")
    fun mapInfo() : ResponseMapInfo {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v4/map-info",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseMapInfo>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseMapInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestRoutes  
    * @return ResponseRoutes
    */
    @Suppress("UNCHECKED_CAST")
    fun routes(requestRoutes: RequestRoutes) : ResponseRoutes {
        val localVariableBody: kotlin.Any? = requestRoutes
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/routes",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseRoutes>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseRoutes
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestSupportedLocations  
    * @return ResponseSupportedLocations
    */
    @Suppress("UNCHECKED_CAST")
    fun supportedLocations(requestSupportedLocations: RequestSupportedLocations) : ResponseSupportedLocations {
        val localVariableBody: kotlin.Any? = requestSupportedLocations
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/supported-locations",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseSupportedLocations>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseSupportedLocations
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestTimeFilter  
    * @return ResponseTimeFilter
    */
    @Suppress("UNCHECKED_CAST")
    fun timeFilter(requestTimeFilter: RequestTimeFilter) : ResponseTimeFilter {
        val localVariableBody: kotlin.Any? = requestTimeFilter
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/time-filter",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseTimeFilter>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseTimeFilter
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestTimeFilterFast  
    * @return ResponseTimeFilterFast
    */
    @Suppress("UNCHECKED_CAST")
    fun timeFilterFast(requestTimeFilterFast: RequestTimeFilterFast) : ResponseTimeFilterFast {
        val localVariableBody: kotlin.Any? = requestTimeFilterFast
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/time-filter/fast",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseTimeFilterFast>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseTimeFilterFast
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestTimeFilterPostcodeDistricts  
    * @return ResponseTimeFilterPostcodeDistricts
    */
    @Suppress("UNCHECKED_CAST")
    fun timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts) : ResponseTimeFilterPostcodeDistricts {
        val localVariableBody: kotlin.Any? = requestTimeFilterPostcodeDistricts
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/time-filter/postcode-districts",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseTimeFilterPostcodeDistricts>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseTimeFilterPostcodeDistricts
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestTimeFilterPostcodeSectors  
    * @return ResponseTimeFilterPostcodeSectors
    */
    @Suppress("UNCHECKED_CAST")
    fun timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors) : ResponseTimeFilterPostcodeSectors {
        val localVariableBody: kotlin.Any? = requestTimeFilterPostcodeSectors
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/time-filter/postcode-sectors",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseTimeFilterPostcodeSectors>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseTimeFilterPostcodeSectors
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestTimeFilterPostcodes  
    * @return ResponseTimeFilterPostcodes
    */
    @Suppress("UNCHECKED_CAST")
    fun timeFilterPostcodes(requestTimeFilterPostcodes: RequestTimeFilterPostcodes) : ResponseTimeFilterPostcodes {
        val localVariableBody: kotlin.Any? = requestTimeFilterPostcodes
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/time-filter/postcodes",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseTimeFilterPostcodes>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseTimeFilterPostcodes
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * 
    * @param requestTimeMap  
    * @return ResponseTimeMap
    */
    @Suppress("UNCHECKED_CAST")
    fun timeMap(requestTimeMap: RequestTimeMap) : ResponseTimeMap {
        val localVariableBody: kotlin.Any? = requestTimeMap
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/v4/time-map",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ResponseTimeMap>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ResponseTimeMap
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
