/**
 * TravelTime Platform API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@igeolise.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api

import java.text.SimpleDateFormat

import org.openapitools.client.model.RequestRoutes
import org.openapitools.client.model.RequestSupportedLocations
import org.openapitools.client.model.RequestTimeFilter
import org.openapitools.client.model.RequestTimeFilterFast
import org.openapitools.client.model.RequestTimeFilterPostcodeDistricts
import org.openapitools.client.model.RequestTimeFilterPostcodeSectors
import org.openapitools.client.model.RequestTimeFilterPostcodes
import org.openapitools.client.model.RequestTimeMap
import org.openapitools.client.model.ResponseError
import org.openapitools.client.model.ResponseGeocoding
import org.openapitools.client.model.ResponseMapInfo
import org.openapitools.client.model.ResponseRoutes
import org.openapitools.client.model.ResponseSupportedLocations
import org.openapitools.client.model.ResponseTimeFilter
import org.openapitools.client.model.ResponseTimeFilterFast
import org.openapitools.client.model.ResponseTimeFilterPostcodeDistricts
import org.openapitools.client.model.ResponseTimeFilterPostcodeSectors
import org.openapitools.client.model.ResponseTimeFilterPostcodes
import org.openapitools.client.model.ResponseTimeMap
import org.openapitools.client.{ApiInvoker, ApiException}

import collection.mutable
import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart
import com.wordnik.swagger.client._
import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import java.net.URI
import java.io.File
import java.util.Date
import java.util.TimeZone
import javax.ws.rs.core.MediaType

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.collection.mutable.HashMap
import scala.util.{Failure, Success, Try}

import org.json4s._

class DefaultApi(
  val defBasePath: String = "https://api.traveltimeapp.com",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new DefaultApiAsyncHelper(client, config)

  /**
   * 
   * 
   *
   * @param focusLat  
   * @param focusLng  
   * @param withinCountry  (optional)
   * @return ResponseGeocoding
   */
  def geocodingReverseSearch(focusLat: Double, focusLng: Double, withinCountry: Option[String] = None): Option[ResponseGeocoding] = {
    val await = Try(Await.result(geocodingReverseSearchAsync(focusLat, focusLng, withinCountry), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param focusLat  
   * @param focusLng  
   * @param withinCountry  (optional)
   * @return Future(ResponseGeocoding)
   */
  def geocodingReverseSearchAsync(focusLat: Double, focusLng: Double, withinCountry: Option[String] = None): Future[ResponseGeocoding] = {
      helper.geocodingReverseSearch(focusLat, focusLng, withinCountry)
  }

  /**
   * 
   * 
   *
   * @param query  
   * @param withinCountry  (optional)
   * @param focusLat  (optional)
   * @param focusLng  (optional)
   * @return ResponseGeocoding
   */
  def geocodingSearch(query: String, withinCountry: Option[String] = None, focusLat: Option[Double] = None, focusLng: Option[Double] = None): Option[ResponseGeocoding] = {
    val await = Try(Await.result(geocodingSearchAsync(query, withinCountry, focusLat, focusLng), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param query  
   * @param withinCountry  (optional)
   * @param focusLat  (optional)
   * @param focusLng  (optional)
   * @return Future(ResponseGeocoding)
   */
  def geocodingSearchAsync(query: String, withinCountry: Option[String] = None, focusLat: Option[Double] = None, focusLng: Option[Double] = None): Future[ResponseGeocoding] = {
      helper.geocodingSearch(query, withinCountry, focusLat, focusLng)
  }

  /**
   * 
   * 
   *
   * @return ResponseMapInfo
   */
  def mapInfo(): Option[ResponseMapInfo] = {
    val await = Try(Await.result(mapInfoAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @return Future(ResponseMapInfo)
   */
  def mapInfoAsync(): Future[ResponseMapInfo] = {
      helper.mapInfo()
  }

  /**
   * 
   * 
   *
   * @param requestRoutes  
   * @return ResponseRoutes
   */
  def routes(requestRoutes: RequestRoutes): Option[ResponseRoutes] = {
    val await = Try(Await.result(routesAsync(requestRoutes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestRoutes  
   * @return Future(ResponseRoutes)
   */
  def routesAsync(requestRoutes: RequestRoutes): Future[ResponseRoutes] = {
      helper.routes(requestRoutes)
  }

  /**
   * 
   * 
   *
   * @param requestSupportedLocations  
   * @return ResponseSupportedLocations
   */
  def supportedLocations(requestSupportedLocations: RequestSupportedLocations): Option[ResponseSupportedLocations] = {
    val await = Try(Await.result(supportedLocationsAsync(requestSupportedLocations), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestSupportedLocations  
   * @return Future(ResponseSupportedLocations)
   */
  def supportedLocationsAsync(requestSupportedLocations: RequestSupportedLocations): Future[ResponseSupportedLocations] = {
      helper.supportedLocations(requestSupportedLocations)
  }

  /**
   * 
   * 
   *
   * @param requestTimeFilter  
   * @return ResponseTimeFilter
   */
  def timeFilter(requestTimeFilter: RequestTimeFilter): Option[ResponseTimeFilter] = {
    val await = Try(Await.result(timeFilterAsync(requestTimeFilter), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestTimeFilter  
   * @return Future(ResponseTimeFilter)
   */
  def timeFilterAsync(requestTimeFilter: RequestTimeFilter): Future[ResponseTimeFilter] = {
      helper.timeFilter(requestTimeFilter)
  }

  /**
   * 
   * 
   *
   * @param requestTimeFilterFast  
   * @return ResponseTimeFilterFast
   */
  def timeFilterFast(requestTimeFilterFast: RequestTimeFilterFast): Option[ResponseTimeFilterFast] = {
    val await = Try(Await.result(timeFilterFastAsync(requestTimeFilterFast), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestTimeFilterFast  
   * @return Future(ResponseTimeFilterFast)
   */
  def timeFilterFastAsync(requestTimeFilterFast: RequestTimeFilterFast): Future[ResponseTimeFilterFast] = {
      helper.timeFilterFast(requestTimeFilterFast)
  }

  /**
   * 
   * 
   *
   * @param requestTimeFilterPostcodeDistricts  
   * @return ResponseTimeFilterPostcodeDistricts
   */
  def timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts): Option[ResponseTimeFilterPostcodeDistricts] = {
    val await = Try(Await.result(timeFilterPostcodeDistrictsAsync(requestTimeFilterPostcodeDistricts), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestTimeFilterPostcodeDistricts  
   * @return Future(ResponseTimeFilterPostcodeDistricts)
   */
  def timeFilterPostcodeDistrictsAsync(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts): Future[ResponseTimeFilterPostcodeDistricts] = {
      helper.timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts)
  }

  /**
   * 
   * 
   *
   * @param requestTimeFilterPostcodeSectors  
   * @return ResponseTimeFilterPostcodeSectors
   */
  def timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors): Option[ResponseTimeFilterPostcodeSectors] = {
    val await = Try(Await.result(timeFilterPostcodeSectorsAsync(requestTimeFilterPostcodeSectors), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestTimeFilterPostcodeSectors  
   * @return Future(ResponseTimeFilterPostcodeSectors)
   */
  def timeFilterPostcodeSectorsAsync(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors): Future[ResponseTimeFilterPostcodeSectors] = {
      helper.timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors)
  }

  /**
   * 
   * 
   *
   * @param requestTimeFilterPostcodes  
   * @return ResponseTimeFilterPostcodes
   */
  def timeFilterPostcodes(requestTimeFilterPostcodes: RequestTimeFilterPostcodes): Option[ResponseTimeFilterPostcodes] = {
    val await = Try(Await.result(timeFilterPostcodesAsync(requestTimeFilterPostcodes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestTimeFilterPostcodes  
   * @return Future(ResponseTimeFilterPostcodes)
   */
  def timeFilterPostcodesAsync(requestTimeFilterPostcodes: RequestTimeFilterPostcodes): Future[ResponseTimeFilterPostcodes] = {
      helper.timeFilterPostcodes(requestTimeFilterPostcodes)
  }

  /**
   * 
   * 
   *
   * @param requestTimeMap  
   * @return ResponseTimeMap
   */
  def timeMap(requestTimeMap: RequestTimeMap): Option[ResponseTimeMap] = {
    val await = Try(Await.result(timeMapAsync(requestTimeMap), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * 
   *
   * @param requestTimeMap  
   * @return Future(ResponseTimeMap)
   */
  def timeMapAsync(requestTimeMap: RequestTimeMap): Future[ResponseTimeMap] = {
      helper.timeMap(requestTimeMap)
  }

}

class DefaultApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def geocodingReverseSearch(focusLat: Double,
    focusLng: Double,
    withinCountry: Option[String] = None
    )(implicit reader: ClientResponseReader[ResponseGeocoding]): Future[ResponseGeocoding] = {
    // create path and map variables
    val path = (addFmt("/v4/geocoding/reverse"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    queryParams += "focus.lat" -> focusLat.toString
    queryParams += "focus.lng" -> focusLng.toString
    withinCountry match {
      case Some(param) => queryParams += "within.country" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def geocodingSearch(query: String,
    withinCountry: Option[String] = None,
    focusLat: Option[Double] = None,
    focusLng: Option[Double] = None
    )(implicit reader: ClientResponseReader[ResponseGeocoding]): Future[ResponseGeocoding] = {
    // create path and map variables
    val path = (addFmt("/v4/geocoding/search"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (query == null) throw new Exception("Missing required parameter 'query' when calling DefaultApi->geocodingSearch")

    queryParams += "query" -> query.toString
    withinCountry match {
      case Some(param) => queryParams += "within.country" -> param.toString
      case _ => queryParams
    }
    focusLat match {
      case Some(param) => queryParams += "focus.lat" -> param.toString
      case _ => queryParams
    }
    focusLng match {
      case Some(param) => queryParams += "focus.lng" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def mapInfo()(implicit reader: ClientResponseReader[ResponseMapInfo]): Future[ResponseMapInfo] = {
    // create path and map variables
    val path = (addFmt("/v4/map-info"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def routes(requestRoutes: RequestRoutes)(implicit reader: ClientResponseReader[ResponseRoutes], writer: RequestWriter[RequestRoutes]): Future[ResponseRoutes] = {
    // create path and map variables
    val path = (addFmt("/v4/routes"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestRoutes == null) throw new Exception("Missing required parameter 'requestRoutes' when calling DefaultApi->routes")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestRoutes))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def supportedLocations(requestSupportedLocations: RequestSupportedLocations)(implicit reader: ClientResponseReader[ResponseSupportedLocations], writer: RequestWriter[RequestSupportedLocations]): Future[ResponseSupportedLocations] = {
    // create path and map variables
    val path = (addFmt("/v4/supported-locations"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestSupportedLocations == null) throw new Exception("Missing required parameter 'requestSupportedLocations' when calling DefaultApi->supportedLocations")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestSupportedLocations))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def timeFilter(requestTimeFilter: RequestTimeFilter)(implicit reader: ClientResponseReader[ResponseTimeFilter], writer: RequestWriter[RequestTimeFilter]): Future[ResponseTimeFilter] = {
    // create path and map variables
    val path = (addFmt("/v4/time-filter"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestTimeFilter == null) throw new Exception("Missing required parameter 'requestTimeFilter' when calling DefaultApi->timeFilter")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestTimeFilter))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def timeFilterFast(requestTimeFilterFast: RequestTimeFilterFast)(implicit reader: ClientResponseReader[ResponseTimeFilterFast], writer: RequestWriter[RequestTimeFilterFast]): Future[ResponseTimeFilterFast] = {
    // create path and map variables
    val path = (addFmt("/v4/time-filter/fast"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestTimeFilterFast == null) throw new Exception("Missing required parameter 'requestTimeFilterFast' when calling DefaultApi->timeFilterFast")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestTimeFilterFast))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts)(implicit reader: ClientResponseReader[ResponseTimeFilterPostcodeDistricts], writer: RequestWriter[RequestTimeFilterPostcodeDistricts]): Future[ResponseTimeFilterPostcodeDistricts] = {
    // create path and map variables
    val path = (addFmt("/v4/time-filter/postcode-districts"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestTimeFilterPostcodeDistricts == null) throw new Exception("Missing required parameter 'requestTimeFilterPostcodeDistricts' when calling DefaultApi->timeFilterPostcodeDistricts")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestTimeFilterPostcodeDistricts))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors)(implicit reader: ClientResponseReader[ResponseTimeFilterPostcodeSectors], writer: RequestWriter[RequestTimeFilterPostcodeSectors]): Future[ResponseTimeFilterPostcodeSectors] = {
    // create path and map variables
    val path = (addFmt("/v4/time-filter/postcode-sectors"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestTimeFilterPostcodeSectors == null) throw new Exception("Missing required parameter 'requestTimeFilterPostcodeSectors' when calling DefaultApi->timeFilterPostcodeSectors")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestTimeFilterPostcodeSectors))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def timeFilterPostcodes(requestTimeFilterPostcodes: RequestTimeFilterPostcodes)(implicit reader: ClientResponseReader[ResponseTimeFilterPostcodes], writer: RequestWriter[RequestTimeFilterPostcodes]): Future[ResponseTimeFilterPostcodes] = {
    // create path and map variables
    val path = (addFmt("/v4/time-filter/postcodes"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestTimeFilterPostcodes == null) throw new Exception("Missing required parameter 'requestTimeFilterPostcodes' when calling DefaultApi->timeFilterPostcodes")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestTimeFilterPostcodes))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def timeMap(requestTimeMap: RequestTimeMap)(implicit reader: ClientResponseReader[ResponseTimeMap], writer: RequestWriter[RequestTimeMap]): Future[ResponseTimeMap] = {
    // create path and map variables
    val path = (addFmt("/v4/time-map"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (requestTimeMap == null) throw new Exception("Missing required parameter 'requestTimeMap' when calling DefaultApi->timeMap")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(requestTimeMap))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
