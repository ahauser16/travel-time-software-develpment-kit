// Models.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

protocol JSONEncodable {
    func encodeToJSON() -> Any
}

public enum ErrorResponse : Error {
    case HttpError(statusCode: Int, data: Data?, error: Error)
    case DecodeError(response: Data?, decodeError: DecodeError)
}

open class Response<T> {
    open let statusCode: Int
    open let header: [String: String]
    open let body: T?

    public init(statusCode: Int, header: [String: String], body: T?) {
        self.statusCode = statusCode
        self.header = header
        self.body = body
    }

    public convenience init(response: HTTPURLResponse, body: T?) {
        let rawHeader = response.allHeaderFields
        var header = [String:String]()
        for case let (key, value) as (String, String) in rawHeader {
            header[key] = value
        }
        self.init(statusCode: response.statusCode, header: header, body: body)
    }
}

public enum Decoded<ValueType> {
    case success(ValueType)
    case failure(DecodeError)
}

public extension Decoded {
    var value: ValueType? {
        switch self {
        case let .success(value):
            return value
        case .failure:
            return nil
        }
    }
}

public enum DecodeError {
    case typeMismatch(expected: String, actual: String)
    case missingKey(key: String)
    case parseError(message: String)
}

private var once = Int()
class Decoders {
    static fileprivate var decoders = Dictionary<String, ((AnyObject, AnyObject?) -> AnyObject)>()

    static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
        let key = "\(T.self)"
        decoders[key] = { decoder($0, $1) as AnyObject }
    }

    static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
        let key = discriminator
        if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
            return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
        if let sourceArray = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in sourceArray {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value):
                    values.append(value)
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        switch Decoders.decode(clazz: T.self, source: source, instance: nil) {
    	    case let .success(value):
                return .success(value)
            case let .failure(error):
                return .failure(error)
        }
    }

    static open func decode<T: RawRepresentable>(clazz: T.Type, source: AnyObject) -> Decoded<T> {
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value):
                    dictionary[key] = value
                case let .failure(error):
                    return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        guard !(source is NSNull), source != nil else { return .success(nil) }
        if let value = source as? T.RawValue {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
        }
    }

    static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
        initialize()
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int32.Type {
            return .success(value)
        }
        if let sourceNumber = source as? NSNumber, let value = sourceNumber.int32Value as? T, T.self is Int64.Type {
     	    return .success(value)
        }
        if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
            return .success(value)
        }
        if let value = source as? T {
            return .success(value)
        }
        if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
            return .success(value)
        }

        let key = "\(T.self)"
        if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
           return value
        } else {
            return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
        }
    }

    //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
    static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
        return .success(decoded.value)
    }

    static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
        if let source = source, !(source is NSNull) {
            switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
            case let .success(value): return .success(value)
            case let .failure(error): return .failure(error)
            }
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> where T: RawRepresentable {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decodeOptional(clazz: T.self, source: sourceValue) {
                case let .success(value): if let value = value { values.append(value) }
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
        if let source = source as? [AnyObject] {
            var values = [T]()
            for sourceValue in source {
                switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                case let .success(value): values.append(value)
                case let .failure(error): return .failure(error)
                }
            }
            return .success(values)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
        if let sourceDictionary = source as? [Key: AnyObject] {
            var dictionary = [Key:T]()
            for (key, value) in sourceDictionary {
                switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                case let .success(value): dictionary[key] = value
                case let .failure(error): return .failure(error)
                }
            }
            return .success(dictionary)
        } else {
            return .success(nil)
        }
    }

    static func decodeOptional<T: RawRepresentable, U: AnyObject>(clazz: T, source: AnyObject) -> Decoded<T?> where T.RawValue == U {
        if let value = source as? U {
            if let enumValue = T.init(rawValue: value) {
                return .success(enumValue)
            } else {
                return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
            }
        } else {
            return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
        }
    }


    private static var __once: () = {
        let formatters = [
            "yyyy-MM-dd",
            "yyyy-MM-dd'T'HH:mm:ssZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ",
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSS",
            "yyyy-MM-dd HH:mm:ss"
        ].map { (format: String) -> DateFormatter in
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.dateFormat = format
            return formatter
        }
        // Decoder for Date
        Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
           if let sourceString = source as? String {
                for formatter in formatters {
                    if let date = formatter.date(from: sourceString) {
                        return .success(date)
                    }
                }
            }
            if let sourceInt = source as? Int {
                // treat as a java date
                return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
            }
            if source is String || source is Int {
                return .failure(.parseError(message: "Could not decode date"))
            } else {
                return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
            }
        }

        // Decoder for ISOFullDate
        Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
            if let string = source as? String,
               let isoDate = ISOFullDate.from(string: string) {
                return .success(isoDate)
            } else {
            	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
            }
        }

        // Decoder for [Coords]
        Decoders.addDecoder(clazz: [Coords].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[Coords]> in
            return Decoders.decode(clazz: [Coords].self, source: source)
        }

        // Decoder for Coords
        Decoders.addDecoder(clazz: Coords.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Coords> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? Coords() : instance as! Coords
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["lat"] as AnyObject?) {
                
                case let .success(value): _result.lat = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["lng"] as AnyObject?) {
                
                case let .success(value): _result.lng = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "Coords", actual: "\(source)"))
            }
        }
        // Decoder for [RequestArrivalTimePeriod]
        Decoders.addDecoder(clazz: [RequestArrivalTimePeriod].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestArrivalTimePeriod]> in
            return Decoders.decode(clazz: [RequestArrivalTimePeriod].self, source: source)
        }

        // Decoder for RequestArrivalTimePeriod
        Decoders.addDecoder(clazz: RequestArrivalTimePeriod.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestArrivalTimePeriod> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestArrivalTimePeriod.self, source: source, instance: instance)
        }
        // Decoder for [RequestLocation]
        Decoders.addDecoder(clazz: [RequestLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestLocation]> in
            return Decoders.decode(clazz: [RequestLocation].self, source: source)
        }

        // Decoder for RequestLocation
        Decoders.addDecoder(clazz: RequestLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestLocation() : instance as! RequestLocation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Coords.self, source: sourceDictionary["coords"] as AnyObject?) {
                
                case let .success(value): _result.coords = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestLocation", actual: "\(source)"))
            }
        }
        // Decoder for [RequestRangeFull]
        Decoders.addDecoder(clazz: [RequestRangeFull].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestRangeFull]> in
            return Decoders.decode(clazz: [RequestRangeFull].self, source: source)
        }

        // Decoder for RequestRangeFull
        Decoders.addDecoder(clazz: RequestRangeFull.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestRangeFull> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestRangeFull() : instance as! RequestRangeFull
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["enabled"] as AnyObject?) {
                
                case let .success(value): _result.enabled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max_results"] as AnyObject?) {
                
                case let .success(value): _result.maxResults = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["width"] as AnyObject?) {
                
                case let .success(value): _result.width = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestRangeFull", actual: "\(source)"))
            }
        }
        // Decoder for [RequestRangeNoMaxResults]
        Decoders.addDecoder(clazz: [RequestRangeNoMaxResults].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestRangeNoMaxResults]> in
            return Decoders.decode(clazz: [RequestRangeNoMaxResults].self, source: source)
        }

        // Decoder for RequestRangeNoMaxResults
        Decoders.addDecoder(clazz: RequestRangeNoMaxResults.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestRangeNoMaxResults> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestRangeNoMaxResults() : instance as! RequestRangeNoMaxResults
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["enabled"] as AnyObject?) {
                
                case let .success(value): _result.enabled = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["width"] as AnyObject?) {
                
                case let .success(value): _result.width = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestRangeNoMaxResults", actual: "\(source)"))
            }
        }
        // Decoder for [RequestRoutes]
        Decoders.addDecoder(clazz: [RequestRoutes].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestRoutes]> in
            return Decoders.decode(clazz: [RequestRoutes].self, source: source)
        }

        // Decoder for RequestRoutes
        Decoders.addDecoder(clazz: RequestRoutes.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestRoutes> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestRoutes() : instance as! RequestRoutes
                switch Decoders.decodeOptional(clazz: [RequestLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestRoutesDepartureSearch].self, source: sourceDictionary["departure_searches"] as AnyObject?) {
                
                case let .success(value): _result.departureSearches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestRoutesArrivalSearch].self, source: sourceDictionary["arrival_searches"] as AnyObject?) {
                
                case let .success(value): _result.arrivalSearches = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestRoutes", actual: "\(source)"))
            }
        }
        // Decoder for [RequestRoutesArrivalSearch]
        Decoders.addDecoder(clazz: [RequestRoutesArrivalSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestRoutesArrivalSearch]> in
            return Decoders.decode(clazz: [RequestRoutesArrivalSearch].self, source: source)
        }

        // Decoder for RequestRoutesArrivalSearch
        Decoders.addDecoder(clazz: RequestRoutesArrivalSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestRoutesArrivalSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestRoutesArrivalSearch() : instance as! RequestRoutesArrivalSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["departure_location_ids"] as AnyObject?) {
                
                case let .success(value): _result.departureLocationIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["arrival_location_id"] as AnyObject?) {
                
                case let .success(value): _result.arrivalLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestRoutesProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestRoutesArrivalSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestRoutesDepartureSearch]
        Decoders.addDecoder(clazz: [RequestRoutesDepartureSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestRoutesDepartureSearch]> in
            return Decoders.decode(clazz: [RequestRoutesDepartureSearch].self, source: source)
        }

        // Decoder for RequestRoutesDepartureSearch
        Decoders.addDecoder(clazz: RequestRoutesDepartureSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestRoutesDepartureSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestRoutesDepartureSearch() : instance as! RequestRoutesDepartureSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["departure_location_id"] as AnyObject?) {
                
                case let .success(value): _result.departureLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["arrival_location_ids"] as AnyObject?) {
                
                case let .success(value): _result.arrivalLocationIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestRoutesProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestRoutesDepartureSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestRoutesProperty]
        Decoders.addDecoder(clazz: [RequestRoutesProperty].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestRoutesProperty]> in
            return Decoders.decode(clazz: [RequestRoutesProperty].self, source: source)
        }

        // Decoder for RequestRoutesProperty
        Decoders.addDecoder(clazz: RequestRoutesProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestRoutesProperty> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestRoutesProperty.self, source: source, instance: instance)
        }
        // Decoder for [RequestSupportedLocations]
        Decoders.addDecoder(clazz: [RequestSupportedLocations].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestSupportedLocations]> in
            return Decoders.decode(clazz: [RequestSupportedLocations].self, source: source)
        }

        // Decoder for RequestSupportedLocations
        Decoders.addDecoder(clazz: RequestSupportedLocations.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestSupportedLocations> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestSupportedLocations() : instance as! RequestSupportedLocations
                switch Decoders.decodeOptional(clazz: [RequestLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestSupportedLocations", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilter]
        Decoders.addDecoder(clazz: [RequestTimeFilter].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilter]> in
            return Decoders.decode(clazz: [RequestTimeFilter].self, source: source)
        }

        // Decoder for RequestTimeFilter
        Decoders.addDecoder(clazz: RequestTimeFilter.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilter> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilter() : instance as! RequestTimeFilter
                switch Decoders.decodeOptional(clazz: [RequestLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterDepartureSearch].self, source: sourceDictionary["departure_searches"] as AnyObject?) {
                
                case let .success(value): _result.departureSearches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterArrivalSearch].self, source: sourceDictionary["arrival_searches"] as AnyObject?) {
                
                case let .success(value): _result.arrivalSearches = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilter", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterArrivalSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterArrivalSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterArrivalSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterArrivalSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterArrivalSearch
        Decoders.addDecoder(clazz: RequestTimeFilterArrivalSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterArrivalSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterArrivalSearch() : instance as! RequestTimeFilterArrivalSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["departure_location_ids"] as AnyObject?) {
                
                case let .success(value): _result.departureLocationIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["arrival_location_id"] as AnyObject?) {
                
                case let .success(value): _result.arrivalLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterArrivalSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterDepartureSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterDepartureSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterDepartureSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterDepartureSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterDepartureSearch
        Decoders.addDecoder(clazz: RequestTimeFilterDepartureSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterDepartureSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterDepartureSearch() : instance as! RequestTimeFilterDepartureSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["departure_location_id"] as AnyObject?) {
                
                case let .success(value): _result.departureLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["arrival_location_ids"] as AnyObject?) {
                
                case let .success(value): _result.arrivalLocationIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterDepartureSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterFast]
        Decoders.addDecoder(clazz: [RequestTimeFilterFast].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterFast]> in
            return Decoders.decode(clazz: [RequestTimeFilterFast].self, source: source)
        }

        // Decoder for RequestTimeFilterFast
        Decoders.addDecoder(clazz: RequestTimeFilterFast.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterFast> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterFast() : instance as! RequestTimeFilterFast
                switch Decoders.decodeOptional(clazz: [RequestLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTimeFilterFastArrivalSearches.self, source: sourceDictionary["arrival_searches"] as AnyObject?) {
                
                case let .success(value): _result.arrivalSearches = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterFast", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterFastArrivalManyToOneSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterFastArrivalManyToOneSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterFastArrivalManyToOneSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterFastArrivalManyToOneSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterFastArrivalManyToOneSearch
        Decoders.addDecoder(clazz: RequestTimeFilterFastArrivalManyToOneSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterFastArrivalManyToOneSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterFastArrivalManyToOneSearch() : instance as! RequestTimeFilterFastArrivalManyToOneSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["arrival_location_id"] as AnyObject?) {
                
                case let .success(value): _result.arrivalLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["departure_location_ids"] as AnyObject?) {
                
                case let .success(value): _result.departureLocationIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportationFast.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestArrivalTimePeriod.self, source: sourceDictionary["arrival_time_period"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTimePeriod = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterFastProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterFastArrivalManyToOneSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterFastArrivalOneToManySearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterFastArrivalOneToManySearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterFastArrivalOneToManySearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterFastArrivalOneToManySearch].self, source: source)
        }

        // Decoder for RequestTimeFilterFastArrivalOneToManySearch
        Decoders.addDecoder(clazz: RequestTimeFilterFastArrivalOneToManySearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterFastArrivalOneToManySearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterFastArrivalOneToManySearch() : instance as! RequestTimeFilterFastArrivalOneToManySearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["departure_location_id"] as AnyObject?) {
                
                case let .success(value): _result.departureLocationId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["arrival_location_ids"] as AnyObject?) {
                
                case let .success(value): _result.arrivalLocationIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportationFast.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestArrivalTimePeriod.self, source: sourceDictionary["arrival_time_period"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTimePeriod = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterFastProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterFastArrivalOneToManySearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterFastArrivalSearches]
        Decoders.addDecoder(clazz: [RequestTimeFilterFastArrivalSearches].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterFastArrivalSearches]> in
            return Decoders.decode(clazz: [RequestTimeFilterFastArrivalSearches].self, source: source)
        }

        // Decoder for RequestTimeFilterFastArrivalSearches
        Decoders.addDecoder(clazz: RequestTimeFilterFastArrivalSearches.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterFastArrivalSearches> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterFastArrivalSearches() : instance as! RequestTimeFilterFastArrivalSearches
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterFastArrivalManyToOneSearch].self, source: sourceDictionary["many_to_one"] as AnyObject?) {
                
                case let .success(value): _result.manyToOne = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterFastArrivalOneToManySearch].self, source: sourceDictionary["one_to_many"] as AnyObject?) {
                
                case let .success(value): _result.oneToMany = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterFastArrivalSearches", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterFastProperty]
        Decoders.addDecoder(clazz: [RequestTimeFilterFastProperty].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterFastProperty]> in
            return Decoders.decode(clazz: [RequestTimeFilterFastProperty].self, source: source)
        }

        // Decoder for RequestTimeFilterFastProperty
        Decoders.addDecoder(clazz: RequestTimeFilterFastProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterFastProperty> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestTimeFilterFastProperty.self, source: source, instance: instance)
        }
        // Decoder for [RequestTimeFilterPostcodeDistricts]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeDistricts].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeDistricts]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeDistricts].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeDistricts
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeDistricts.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeDistricts> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodeDistricts() : instance as! RequestTimeFilterPostcodeDistricts
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeDistrictsDepartureSearch].self, source: sourceDictionary["departure_searches"] as AnyObject?) {
                
                case let .success(value): _result.departureSearches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeDistrictsArrivalSearch].self, source: sourceDictionary["arrival_searches"] as AnyObject?) {
                
                case let .success(value): _result.arrivalSearches = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodeDistricts", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodeDistrictsArrivalSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeDistrictsArrivalSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeDistrictsArrivalSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeDistrictsArrivalSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeDistrictsArrivalSearch
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeDistrictsArrivalSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeDistrictsArrivalSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodeDistrictsArrivalSearch() : instance as! RequestTimeFilterPostcodeDistrictsArrivalSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["reachable_postcodes_threshold"] as AnyObject?) {
                
                case let .success(value): _result.reachablePostcodesThreshold = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeDistrictsProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodeDistrictsArrivalSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodeDistrictsDepartureSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeDistrictsDepartureSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeDistrictsDepartureSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeDistrictsDepartureSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeDistrictsDepartureSearch
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeDistrictsDepartureSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeDistrictsDepartureSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodeDistrictsDepartureSearch() : instance as! RequestTimeFilterPostcodeDistrictsDepartureSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["reachable_postcodes_threshold"] as AnyObject?) {
                
                case let .success(value): _result.reachablePostcodesThreshold = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeDistrictsProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodeDistrictsDepartureSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodeDistrictsProperty]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeDistrictsProperty].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeDistrictsProperty]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeDistrictsProperty].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeDistrictsProperty
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeDistrictsProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeDistrictsProperty> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestTimeFilterPostcodeDistrictsProperty.self, source: source, instance: instance)
        }
        // Decoder for [RequestTimeFilterPostcodeSectors]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeSectors].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeSectors]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeSectors].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeSectors
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeSectors.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeSectors> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodeSectors() : instance as! RequestTimeFilterPostcodeSectors
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeSectorsDepartureSearch].self, source: sourceDictionary["departure_searches"] as AnyObject?) {
                
                case let .success(value): _result.departureSearches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeSectorsArrivalSearch].self, source: sourceDictionary["arrival_searches"] as AnyObject?) {
                
                case let .success(value): _result.arrivalSearches = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodeSectors", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodeSectorsArrivalSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeSectorsArrivalSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeSectorsArrivalSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeSectorsArrivalSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeSectorsArrivalSearch
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeSectorsArrivalSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeSectorsArrivalSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodeSectorsArrivalSearch() : instance as! RequestTimeFilterPostcodeSectorsArrivalSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["reachable_postcodes_threshold"] as AnyObject?) {
                
                case let .success(value): _result.reachablePostcodesThreshold = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeSectorsProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodeSectorsArrivalSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodeSectorsDepartureSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeSectorsDepartureSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeSectorsDepartureSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeSectorsDepartureSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeSectorsDepartureSearch
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeSectorsDepartureSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeSectorsDepartureSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodeSectorsDepartureSearch() : instance as! RequestTimeFilterPostcodeSectorsDepartureSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["reachable_postcodes_threshold"] as AnyObject?) {
                
                case let .success(value): _result.reachablePostcodesThreshold = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodeSectorsProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodeSectorsDepartureSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodeSectorsProperty]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodeSectorsProperty].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodeSectorsProperty]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodeSectorsProperty].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodeSectorsProperty
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodeSectorsProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodeSectorsProperty> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestTimeFilterPostcodeSectorsProperty.self, source: source, instance: instance)
        }
        // Decoder for [RequestTimeFilterPostcodes]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodes].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodes]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodes].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodes
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodes.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodes> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodes() : instance as! RequestTimeFilterPostcodes
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodesDepartureSearch].self, source: sourceDictionary["departure_searches"] as AnyObject?) {
                
                case let .success(value): _result.departureSearches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodesArrivalSearch].self, source: sourceDictionary["arrival_searches"] as AnyObject?) {
                
                case let .success(value): _result.arrivalSearches = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodes", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodesArrivalSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodesArrivalSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodesArrivalSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodesArrivalSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodesArrivalSearch
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodesArrivalSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodesArrivalSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodesArrivalSearch() : instance as! RequestTimeFilterPostcodesArrivalSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodesProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodesArrivalSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodesDepartureSearch]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodesDepartureSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodesDepartureSearch]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodesDepartureSearch].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodesDepartureSearch
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodesDepartureSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodesDepartureSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeFilterPostcodesDepartureSearch() : instance as! RequestTimeFilterPostcodesDepartureSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeFilterPostcodesProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeFull.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeFilterPostcodesDepartureSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeFilterPostcodesProperty]
        Decoders.addDecoder(clazz: [RequestTimeFilterPostcodesProperty].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterPostcodesProperty]> in
            return Decoders.decode(clazz: [RequestTimeFilterPostcodesProperty].self, source: source)
        }

        // Decoder for RequestTimeFilterPostcodesProperty
        Decoders.addDecoder(clazz: RequestTimeFilterPostcodesProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterPostcodesProperty> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestTimeFilterPostcodesProperty.self, source: source, instance: instance)
        }
        // Decoder for [RequestTimeFilterProperty]
        Decoders.addDecoder(clazz: [RequestTimeFilterProperty].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeFilterProperty]> in
            return Decoders.decode(clazz: [RequestTimeFilterProperty].self, source: source)
        }

        // Decoder for RequestTimeFilterProperty
        Decoders.addDecoder(clazz: RequestTimeFilterProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeFilterProperty> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestTimeFilterProperty.self, source: source, instance: instance)
        }
        // Decoder for [RequestTimeMap]
        Decoders.addDecoder(clazz: [RequestTimeMap].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeMap]> in
            return Decoders.decode(clazz: [RequestTimeMap].self, source: source)
        }

        // Decoder for RequestTimeMap
        Decoders.addDecoder(clazz: RequestTimeMap.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeMap> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeMap() : instance as! RequestTimeMap
                switch Decoders.decodeOptional(clazz: [RequestTimeMapDepartureSearch].self, source: sourceDictionary["departure_searches"] as AnyObject?) {
                
                case let .success(value): _result.departureSearches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeMapArrivalSearch].self, source: sourceDictionary["arrival_searches"] as AnyObject?) {
                
                case let .success(value): _result.arrivalSearches = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestUnionOnIntersection].self, source: sourceDictionary["unions"] as AnyObject?) {
                
                case let .success(value): _result.unions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestUnionOnIntersection].self, source: sourceDictionary["intersections"] as AnyObject?) {
                
                case let .success(value): _result.intersections = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeMap", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeMapArrivalSearch]
        Decoders.addDecoder(clazz: [RequestTimeMapArrivalSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeMapArrivalSearch]> in
            return Decoders.decode(clazz: [RequestTimeMapArrivalSearch].self, source: source)
        }

        // Decoder for RequestTimeMapArrivalSearch
        Decoders.addDecoder(clazz: RequestTimeMapArrivalSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeMapArrivalSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeMapArrivalSearch() : instance as! RequestTimeMapArrivalSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Coords.self, source: sourceDictionary["coords"] as AnyObject?) {
                
                case let .success(value): _result.coords = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeMapProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeNoMaxResults.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeMapArrivalSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeMapDepartureSearch]
        Decoders.addDecoder(clazz: [RequestTimeMapDepartureSearch].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeMapDepartureSearch]> in
            return Decoders.decode(clazz: [RequestTimeMapDepartureSearch].self, source: source)
        }

        // Decoder for RequestTimeMapDepartureSearch
        Decoders.addDecoder(clazz: RequestTimeMapDepartureSearch.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeMapDepartureSearch> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTimeMapDepartureSearch() : instance as! RequestTimeMapDepartureSearch
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Coords.self, source: sourceDictionary["coords"] as AnyObject?) {
                
                case let .success(value): _result.coords = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestTransportation.self, source: sourceDictionary["transportation"] as AnyObject?) {
                
                case let .success(value): _result.transportation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [RequestTimeMapProperty].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: RequestRangeNoMaxResults.self, source: sourceDictionary["range"] as AnyObject?) {
                
                case let .success(value): _result.range = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTimeMapDepartureSearch", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTimeMapProperty]
        Decoders.addDecoder(clazz: [RequestTimeMapProperty].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTimeMapProperty]> in
            return Decoders.decode(clazz: [RequestTimeMapProperty].self, source: source)
        }

        // Decoder for RequestTimeMapProperty
        Decoders.addDecoder(clazz: RequestTimeMapProperty.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTimeMapProperty> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: RequestTimeMapProperty.self, source: source, instance: instance)
        }
        // Decoder for [RequestTransportation]
        Decoders.addDecoder(clazz: [RequestTransportation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTransportation]> in
            return Decoders.decode(clazz: [RequestTransportation].self, source: source)
        }

        // Decoder for RequestTransportation
        Decoders.addDecoder(clazz: RequestTransportation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTransportation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTransportation() : instance as! RequestTransportation
                switch Decoders.decodeOptional(clazz: RequestTransportation.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["pt_change_delay"] as AnyObject?) {
                
                case let .success(value): _result.ptChangeDelay = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["walking_time"] as AnyObject?) {
                
                case let .success(value): _result.walkingTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["driving_time_to_station"] as AnyObject?) {
                
                case let .success(value): _result.drivingTimeToStation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["parking_time"] as AnyObject?) {
                
                case let .success(value): _result.parkingTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["boarding_time"] as AnyObject?) {
                
                case let .success(value): _result.boardingTime = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTransportation", actual: "\(source)"))
            }
        }
        // Decoder for [RequestTransportationFast]
        Decoders.addDecoder(clazz: [RequestTransportationFast].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestTransportationFast]> in
            return Decoders.decode(clazz: [RequestTransportationFast].self, source: source)
        }

        // Decoder for RequestTransportationFast
        Decoders.addDecoder(clazz: RequestTransportationFast.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestTransportationFast> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestTransportationFast() : instance as! RequestTransportationFast
                switch Decoders.decodeOptional(clazz: RequestTransportationFast.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestTransportationFast", actual: "\(source)"))
            }
        }
        // Decoder for [RequestUnionOnIntersection]
        Decoders.addDecoder(clazz: [RequestUnionOnIntersection].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[RequestUnionOnIntersection]> in
            return Decoders.decode(clazz: [RequestUnionOnIntersection].self, source: source)
        }

        // Decoder for RequestUnionOnIntersection
        Decoders.addDecoder(clazz: RequestUnionOnIntersection.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<RequestUnionOnIntersection> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? RequestUnionOnIntersection() : instance as! RequestUnionOnIntersection
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["search_ids"] as AnyObject?) {
                
                case let .success(value): _result.searchIds = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "RequestUnionOnIntersection", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseBoundingBox]
        Decoders.addDecoder(clazz: [ResponseBoundingBox].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseBoundingBox]> in
            return Decoders.decode(clazz: [ResponseBoundingBox].self, source: source)
        }

        // Decoder for ResponseBoundingBox
        Decoders.addDecoder(clazz: ResponseBoundingBox.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseBoundingBox> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseBoundingBox() : instance as! ResponseBoundingBox
                switch Decoders.decodeOptional(clazz: ResponseBox.self, source: sourceDictionary["envelope"] as AnyObject?) {
                
                case let .success(value): _result.envelope = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseBox].self, source: sourceDictionary["boxes"] as AnyObject?) {
                
                case let .success(value): _result.boxes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseBoundingBox", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseBox]
        Decoders.addDecoder(clazz: [ResponseBox].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseBox]> in
            return Decoders.decode(clazz: [ResponseBox].self, source: source)
        }

        // Decoder for ResponseBox
        Decoders.addDecoder(clazz: ResponseBox.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseBox> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseBox() : instance as! ResponseBox
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["min_lat"] as AnyObject?) {
                
                case let .success(value): _result.minLat = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["max_lat"] as AnyObject?) {
                
                case let .success(value): _result.maxLat = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["min_lng"] as AnyObject?) {
                
                case let .success(value): _result.minLng = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["max_lng"] as AnyObject?) {
                
                case let .success(value): _result.maxLng = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseBox", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseDistanceBreakdownItem]
        Decoders.addDecoder(clazz: [ResponseDistanceBreakdownItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseDistanceBreakdownItem]> in
            return Decoders.decode(clazz: [ResponseDistanceBreakdownItem].self, source: source)
        }

        // Decoder for ResponseDistanceBreakdownItem
        Decoders.addDecoder(clazz: ResponseDistanceBreakdownItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseDistanceBreakdownItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseDistanceBreakdownItem() : instance as! ResponseDistanceBreakdownItem
                switch Decoders.decodeOptional(clazz: ResponseTransportationMode.self, source: sourceDictionary["mode"] as AnyObject?) {
                
                case let .success(value): _result.mode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["distance"] as AnyObject?) {
                
                case let .success(value): _result.distance = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseDistanceBreakdownItem", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseError]
        Decoders.addDecoder(clazz: [ResponseError].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseError]> in
            return Decoders.decode(clazz: [ResponseError].self, source: source)
        }

        // Decoder for ResponseError
        Decoders.addDecoder(clazz: ResponseError.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseError> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseError() : instance as! ResponseError
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["http_status"] as AnyObject?) {
                
                case let .success(value): _result.httpStatus = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["error_code"] as AnyObject?) {
                
                case let .success(value): _result.errorCode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["description"] as AnyObject?) {
                
                case let .success(value): _result.description = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["documentation_link"] as AnyObject?) {
                
                case let .success(value): _result.documentationLink = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String:[String]].self, source: sourceDictionary["additional_info"] as AnyObject?) {
                
                case let .success(value): _result.additionalInfo = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseError", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseFareTicket]
        Decoders.addDecoder(clazz: [ResponseFareTicket].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseFareTicket]> in
            return Decoders.decode(clazz: [ResponseFareTicket].self, source: source)
        }

        // Decoder for ResponseFareTicket
        Decoders.addDecoder(clazz: ResponseFareTicket.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseFareTicket> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseFareTicket() : instance as! ResponseFareTicket
                switch Decoders.decodeOptional(clazz: ResponseFareTicket.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["price"] as AnyObject?) {
                
                case let .success(value): _result.price = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["currency"] as AnyObject?) {
                
                case let .success(value): _result.currency = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseFareTicket", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseFares]
        Decoders.addDecoder(clazz: [ResponseFares].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseFares]> in
            return Decoders.decode(clazz: [ResponseFares].self, source: source)
        }

        // Decoder for ResponseFares
        Decoders.addDecoder(clazz: ResponseFares.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseFares> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseFares() : instance as! ResponseFares
                switch Decoders.decodeOptional(clazz: [ResponseFaresBreakdownItem].self, source: sourceDictionary["breakdown"] as AnyObject?) {
                
                case let .success(value): _result.breakdown = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseFareTicket].self, source: sourceDictionary["tickets_total"] as AnyObject?) {
                
                case let .success(value): _result.ticketsTotal = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseFares", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseFaresBreakdownItem]
        Decoders.addDecoder(clazz: [ResponseFaresBreakdownItem].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseFaresBreakdownItem]> in
            return Decoders.decode(clazz: [ResponseFaresBreakdownItem].self, source: source)
        }

        // Decoder for ResponseFaresBreakdownItem
        Decoders.addDecoder(clazz: ResponseFaresBreakdownItem.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseFaresBreakdownItem> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseFaresBreakdownItem() : instance as! ResponseFaresBreakdownItem
                switch Decoders.decodeOptional(clazz: [ResponseTransportationMode].self, source: sourceDictionary["modes"] as AnyObject?) {
                
                case let .success(value): _result.modes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Int32].self, source: sourceDictionary["route_part_ids"] as AnyObject?) {
                
                case let .success(value): _result.routePartIds = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseFareTicket].self, source: sourceDictionary["tickets"] as AnyObject?) {
                
                case let .success(value): _result.tickets = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseFaresBreakdownItem", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseFaresFast]
        Decoders.addDecoder(clazz: [ResponseFaresFast].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseFaresFast]> in
            return Decoders.decode(clazz: [ResponseFaresFast].self, source: source)
        }

        // Decoder for ResponseFaresFast
        Decoders.addDecoder(clazz: ResponseFaresFast.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseFaresFast> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseFaresFast() : instance as! ResponseFaresFast
                switch Decoders.decodeOptional(clazz: [ResponseFareTicket].self, source: sourceDictionary["tickets_total"] as AnyObject?) {
                
                case let .success(value): _result.ticketsTotal = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseFaresFast", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseGeocoding]
        Decoders.addDecoder(clazz: [ResponseGeocoding].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseGeocoding]> in
            return Decoders.decode(clazz: [ResponseGeocoding].self, source: source)
        }

        // Decoder for ResponseGeocoding
        Decoders.addDecoder(clazz: ResponseGeocoding.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseGeocoding> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseGeocoding() : instance as! ResponseGeocoding
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseGeocodingGeoJsonFeature].self, source: sourceDictionary["features"] as AnyObject?) {
                
                case let .success(value): _result.features = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseGeocoding", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseGeocodingGeoJsonFeature]
        Decoders.addDecoder(clazz: [ResponseGeocodingGeoJsonFeature].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseGeocodingGeoJsonFeature]> in
            return Decoders.decode(clazz: [ResponseGeocodingGeoJsonFeature].self, source: source)
        }

        // Decoder for ResponseGeocodingGeoJsonFeature
        Decoders.addDecoder(clazz: ResponseGeocodingGeoJsonFeature.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseGeocodingGeoJsonFeature> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseGeocodingGeoJsonFeature() : instance as! ResponseGeocodingGeoJsonFeature
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseGeocodingGeometry.self, source: sourceDictionary["geometry"] as AnyObject?) {
                
                case let .success(value): _result.geometry = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseGeocodingProperties.self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseGeocodingGeoJsonFeature", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseGeocodingGeometry]
        Decoders.addDecoder(clazz: [ResponseGeocodingGeometry].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseGeocodingGeometry]> in
            return Decoders.decode(clazz: [ResponseGeocodingGeometry].self, source: source)
        }

        // Decoder for ResponseGeocodingGeometry
        Decoders.addDecoder(clazz: ResponseGeocodingGeometry.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseGeocodingGeometry> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseGeocodingGeometry() : instance as! ResponseGeocodingGeometry
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Double].self, source: sourceDictionary["coordinates"] as AnyObject?) {
                
                case let .success(value): _result.coordinates = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseGeocodingGeometry", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseGeocodingProperties]
        Decoders.addDecoder(clazz: [ResponseGeocodingProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseGeocodingProperties]> in
            return Decoders.decode(clazz: [ResponseGeocodingProperties].self, source: source)
        }

        // Decoder for ResponseGeocodingProperties
        Decoders.addDecoder(clazz: ResponseGeocodingProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseGeocodingProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseGeocodingProperties() : instance as! ResponseGeocodingProperties
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["label"] as AnyObject?) {
                
                case let .success(value): _result.label = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["score"] as AnyObject?) {
                
                case let .success(value): _result.score = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["house_number"] as AnyObject?) {
                
                case let .success(value): _result.houseNumber = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["street"] as AnyObject?) {
                
                case let .success(value): _result.street = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["region"] as AnyObject?) {
                
                case let .success(value): _result.region = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["region_code"] as AnyObject?) {
                
                case let .success(value): _result.regionCode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["neighbourhood"] as AnyObject?) {
                
                case let .success(value): _result.neighbourhood = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["county"] as AnyObject?) {
                
                case let .success(value): _result.county = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["macroregion"] as AnyObject?) {
                
                case let .success(value): _result.macroregion = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["city"] as AnyObject?) {
                
                case let .success(value): _result.city = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country"] as AnyObject?) {
                
                case let .success(value): _result.country = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["country_code"] as AnyObject?) {
                
                case let .success(value): _result.countryCode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["continent"] as AnyObject?) {
                
                case let .success(value): _result.continent = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["postcode"] as AnyObject?) {
                
                case let .success(value): _result.postcode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseMapInfoFeatures.self, source: sourceDictionary["features"] as AnyObject?) {
                
                case let .success(value): _result.features = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseGeocodingProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseMapInfo]
        Decoders.addDecoder(clazz: [ResponseMapInfo].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseMapInfo]> in
            return Decoders.decode(clazz: [ResponseMapInfo].self, source: source)
        }

        // Decoder for ResponseMapInfo
        Decoders.addDecoder(clazz: ResponseMapInfo.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseMapInfo> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseMapInfo() : instance as! ResponseMapInfo
                switch Decoders.decodeOptional(clazz: [ResponseMapInfoMap].self, source: sourceDictionary["maps"] as AnyObject?) {
                
                case let .success(value): _result.maps = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseMapInfo", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseMapInfoFeatures]
        Decoders.addDecoder(clazz: [ResponseMapInfoFeatures].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseMapInfoFeatures]> in
            return Decoders.decode(clazz: [ResponseMapInfoFeatures].self, source: source)
        }

        // Decoder for ResponseMapInfoFeatures
        Decoders.addDecoder(clazz: ResponseMapInfoFeatures.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseMapInfoFeatures> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseMapInfoFeatures() : instance as! ResponseMapInfoFeatures
                switch Decoders.decodeOptional(clazz: ResponseMapInfoFeaturesPublicTransport.self, source: sourceDictionary["public_transport"] as AnyObject?) {
                
                case let .success(value): _result.publicTransport = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["fares"] as AnyObject?) {
                
                case let .success(value): _result.fares = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["postcodes"] as AnyObject?) {
                
                case let .success(value): _result.postcodes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseMapInfoFeatures", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseMapInfoFeaturesPublicTransport]
        Decoders.addDecoder(clazz: [ResponseMapInfoFeaturesPublicTransport].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseMapInfoFeaturesPublicTransport]> in
            return Decoders.decode(clazz: [ResponseMapInfoFeaturesPublicTransport].self, source: source)
        }

        // Decoder for ResponseMapInfoFeaturesPublicTransport
        Decoders.addDecoder(clazz: ResponseMapInfoFeaturesPublicTransport.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseMapInfoFeaturesPublicTransport> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseMapInfoFeaturesPublicTransport() : instance as! ResponseMapInfoFeaturesPublicTransport
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date_start"] as AnyObject?) {
                
                case let .success(value): _result.dateStart = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date_end"] as AnyObject?) {
                
                case let .success(value): _result.dateEnd = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseMapInfoFeaturesPublicTransport", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseMapInfoMap]
        Decoders.addDecoder(clazz: [ResponseMapInfoMap].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseMapInfoMap]> in
            return Decoders.decode(clazz: [ResponseMapInfoMap].self, source: source)
        }

        // Decoder for ResponseMapInfoMap
        Decoders.addDecoder(clazz: ResponseMapInfoMap.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseMapInfoMap> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseMapInfoMap() : instance as! ResponseMapInfoMap
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                
                case let .success(value): _result.name = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseMapInfoFeatures.self, source: sourceDictionary["features"] as AnyObject?) {
                
                case let .success(value): _result.features = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseMapInfoMap", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseRoute]
        Decoders.addDecoder(clazz: [ResponseRoute].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseRoute]> in
            return Decoders.decode(clazz: [ResponseRoute].self, source: source)
        }

        // Decoder for ResponseRoute
        Decoders.addDecoder(clazz: ResponseRoute.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseRoute> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseRoute() : instance as! ResponseRoute
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["departure_time"] as AnyObject?) {
                
                case let .success(value): _result.departureTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["arrival_time"] as AnyObject?) {
                
                case let .success(value): _result.arrivalTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseRoutePart].self, source: sourceDictionary["parts"] as AnyObject?) {
                
                case let .success(value): _result.parts = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseRoute", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseRoutePart]
        Decoders.addDecoder(clazz: [ResponseRoutePart].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseRoutePart]> in
            return Decoders.decode(clazz: [ResponseRoutePart].self, source: source)
        }

        // Decoder for ResponseRoutePart
        Decoders.addDecoder(clazz: ResponseRoutePart.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseRoutePart> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseRoutePart() : instance as! ResponseRoutePart
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseRoutePart.ModelType.self, source: sourceDictionary["type"] as AnyObject?) {
                
                case let .success(value): _result.type = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTransportationMode.self, source: sourceDictionary["mode"] as AnyObject?) {
                
                case let .success(value): _result.mode = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["directions"] as AnyObject?) {
                
                case let .success(value): _result.directions = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["distance"] as AnyObject?) {
                
                case let .success(value): _result.distance = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [Coords].self, source: sourceDictionary["coords"] as AnyObject?) {
                
                case let .success(value): _result.coords = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["direction"] as AnyObject?) {
                
                case let .success(value): _result.direction = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["road"] as AnyObject?) {
                
                case let .success(value): _result.road = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["turn"] as AnyObject?) {
                
                case let .success(value): _result.turn = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["line"] as AnyObject?) {
                
                case let .success(value): _result.line = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["departure_station"] as AnyObject?) {
                
                case let .success(value): _result.departureStation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["arrival_station"] as AnyObject?) {
                
                case let .success(value): _result.arrivalStation = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["departs_at"] as AnyObject?) {
                
                case let .success(value): _result.departsAt = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["arrives_at"] as AnyObject?) {
                
                case let .success(value): _result.arrivesAt = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["num_stops"] as AnyObject?) {
                
                case let .success(value): _result.numStops = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseRoutePart", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseRoutes]
        Decoders.addDecoder(clazz: [ResponseRoutes].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseRoutes]> in
            return Decoders.decode(clazz: [ResponseRoutes].self, source: source)
        }

        // Decoder for ResponseRoutes
        Decoders.addDecoder(clazz: ResponseRoutes.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseRoutes> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseRoutes() : instance as! ResponseRoutes
                switch Decoders.decodeOptional(clazz: [ResponseRoutesResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseRoutes", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseRoutesLocation]
        Decoders.addDecoder(clazz: [ResponseRoutesLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseRoutesLocation]> in
            return Decoders.decode(clazz: [ResponseRoutesLocation].self, source: source)
        }

        // Decoder for ResponseRoutesLocation
        Decoders.addDecoder(clazz: ResponseRoutesLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseRoutesLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseRoutesLocation() : instance as! ResponseRoutesLocation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseRoutesProperties].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseRoutesLocation", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseRoutesProperties]
        Decoders.addDecoder(clazz: [ResponseRoutesProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseRoutesProperties]> in
            return Decoders.decode(clazz: [ResponseRoutesProperties].self, source: source)
        }

        // Decoder for ResponseRoutesProperties
        Decoders.addDecoder(clazz: ResponseRoutesProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseRoutesProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseRoutesProperties() : instance as! ResponseRoutesProperties
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["distance"] as AnyObject?) {
                
                case let .success(value): _result.distance = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseFares.self, source: sourceDictionary["fares"] as AnyObject?) {
                
                case let .success(value): _result.fares = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseRoute.self, source: sourceDictionary["route"] as AnyObject?) {
                
                case let .success(value): _result.route = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseRoutesProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseRoutesResult]
        Decoders.addDecoder(clazz: [ResponseRoutesResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseRoutesResult]> in
            return Decoders.decode(clazz: [ResponseRoutesResult].self, source: source)
        }

        // Decoder for ResponseRoutesResult
        Decoders.addDecoder(clazz: ResponseRoutesResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseRoutesResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseRoutesResult() : instance as! ResponseRoutesResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseRoutesLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["unreachable"] as AnyObject?) {
                
                case let .success(value): _result.unreachable = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseRoutesResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseShape]
        Decoders.addDecoder(clazz: [ResponseShape].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseShape]> in
            return Decoders.decode(clazz: [ResponseShape].self, source: source)
        }

        // Decoder for ResponseShape
        Decoders.addDecoder(clazz: ResponseShape.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseShape> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseShape() : instance as! ResponseShape
                switch Decoders.decodeOptional(clazz: [Coords].self, source: sourceDictionary["shell"] as AnyObject?) {
                
                case let .success(value): _result.shell = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [[Coords]].self, source: sourceDictionary["holes"] as AnyObject?) {
                
                case let .success(value): _result.holes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseShape", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseSupportedLocation]
        Decoders.addDecoder(clazz: [ResponseSupportedLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseSupportedLocation]> in
            return Decoders.decode(clazz: [ResponseSupportedLocation].self, source: source)
        }

        // Decoder for ResponseSupportedLocation
        Decoders.addDecoder(clazz: ResponseSupportedLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseSupportedLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseSupportedLocation() : instance as! ResponseSupportedLocation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["map_name"] as AnyObject?) {
                
                case let .success(value): _result.mapName = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseSupportedLocation", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseSupportedLocations]
        Decoders.addDecoder(clazz: [ResponseSupportedLocations].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseSupportedLocations]> in
            return Decoders.decode(clazz: [ResponseSupportedLocations].self, source: source)
        }

        // Decoder for ResponseSupportedLocations
        Decoders.addDecoder(clazz: ResponseSupportedLocations.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseSupportedLocations> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseSupportedLocations() : instance as! ResponseSupportedLocations
                switch Decoders.decodeOptional(clazz: [ResponseSupportedLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["unsupported_locations"] as AnyObject?) {
                
                case let .success(value): _result.unsupportedLocations = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseSupportedLocations", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilter]
        Decoders.addDecoder(clazz: [ResponseTimeFilter].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilter]> in
            return Decoders.decode(clazz: [ResponseTimeFilter].self, source: source)
        }

        // Decoder for ResponseTimeFilter
        Decoders.addDecoder(clazz: ResponseTimeFilter.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilter> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilter() : instance as! ResponseTimeFilter
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilter", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterFast]
        Decoders.addDecoder(clazz: [ResponseTimeFilterFast].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterFast]> in
            return Decoders.decode(clazz: [ResponseTimeFilterFast].self, source: source)
        }

        // Decoder for ResponseTimeFilterFast
        Decoders.addDecoder(clazz: ResponseTimeFilterFast.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterFast> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterFast() : instance as! ResponseTimeFilterFast
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterFastResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterFast", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterFastLocation]
        Decoders.addDecoder(clazz: [ResponseTimeFilterFastLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterFastLocation]> in
            return Decoders.decode(clazz: [ResponseTimeFilterFastLocation].self, source: source)
        }

        // Decoder for ResponseTimeFilterFastLocation
        Decoders.addDecoder(clazz: ResponseTimeFilterFastLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterFastLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterFastLocation() : instance as! ResponseTimeFilterFastLocation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterFastProperties].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterFastLocation", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterFastProperties]
        Decoders.addDecoder(clazz: [ResponseTimeFilterFastProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterFastProperties]> in
            return Decoders.decode(clazz: [ResponseTimeFilterFastProperties].self, source: source)
        }

        // Decoder for ResponseTimeFilterFastProperties
        Decoders.addDecoder(clazz: ResponseTimeFilterFastProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterFastProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterFastProperties() : instance as! ResponseTimeFilterFastProperties
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseFaresFast.self, source: sourceDictionary["fares"] as AnyObject?) {
                
                case let .success(value): _result.fares = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterFastProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterFastResult]
        Decoders.addDecoder(clazz: [ResponseTimeFilterFastResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterFastResult]> in
            return Decoders.decode(clazz: [ResponseTimeFilterFastResult].self, source: source)
        }

        // Decoder for ResponseTimeFilterFastResult
        Decoders.addDecoder(clazz: ResponseTimeFilterFastResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterFastResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterFastResult() : instance as! ResponseTimeFilterFastResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterFastLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["unreachable"] as AnyObject?) {
                
                case let .success(value): _result.unreachable = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterFastResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterLocation]
        Decoders.addDecoder(clazz: [ResponseTimeFilterLocation].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterLocation]> in
            return Decoders.decode(clazz: [ResponseTimeFilterLocation].self, source: source)
        }

        // Decoder for ResponseTimeFilterLocation
        Decoders.addDecoder(clazz: ResponseTimeFilterLocation.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterLocation> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterLocation() : instance as! ResponseTimeFilterLocation
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["id"] as AnyObject?) {
                
                case let .success(value): _result.id = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterProperties].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterLocation", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcode]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcode].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcode]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcode].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcode
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcode.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcode> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcode() : instance as! ResponseTimeFilterPostcode
                switch Decoders.decodeOptional(clazz: ModelString.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): _result.code = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterPostcodesProperties].self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcode", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeDistrict]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeDistrict].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeDistrict]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeDistrict].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeDistrict
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeDistrict.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeDistrict> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeDistrict() : instance as! ResponseTimeFilterPostcodeDistrict
                switch Decoders.decodeOptional(clazz: ModelString.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): _result.code = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTimeFilterPostcodeDistrictProperties.self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeDistrict", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeDistrictProperties]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeDistrictProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeDistrictProperties]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeDistrictProperties].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeDistrictProperties
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeDistrictProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeDistrictProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeDistrictProperties() : instance as! ResponseTimeFilterPostcodeDistrictProperties
                switch Decoders.decodeOptional(clazz: ResponseTravelTimeStatistics.self, source: sourceDictionary["travel_time_reachable"] as AnyObject?) {
                
                case let .success(value): _result.travelTimeReachable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTravelTimeStatistics.self, source: sourceDictionary["travel_time_all"] as AnyObject?) {
                
                case let .success(value): _result.travelTimeAll = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["coverage"] as AnyObject?) {
                
                case let .success(value): _result.coverage = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeDistrictProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeDistricts]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeDistricts].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeDistricts]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeDistricts].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeDistricts
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeDistricts.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeDistricts> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeDistricts() : instance as! ResponseTimeFilterPostcodeDistricts
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterPostcodeDistrictsResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeDistricts", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeDistrictsResult]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeDistrictsResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeDistrictsResult]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeDistrictsResult].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeDistrictsResult
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeDistrictsResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeDistrictsResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeDistrictsResult() : instance as! ResponseTimeFilterPostcodeDistrictsResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterPostcodeDistrict].self, source: sourceDictionary["districts"] as AnyObject?) {
                
                case let .success(value): _result.districts = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeDistrictsResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeSector]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeSector].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeSector]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeSector].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeSector
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeSector.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeSector> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeSector() : instance as! ResponseTimeFilterPostcodeSector
                switch Decoders.decodeOptional(clazz: ModelString.self, source: sourceDictionary["code"] as AnyObject?) {
                
                case let .success(value): _result.code = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTimeFilterPostcodeSectorProperties.self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeSector", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeSectorProperties]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeSectorProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeSectorProperties]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeSectorProperties].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeSectorProperties
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeSectorProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeSectorProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeSectorProperties() : instance as! ResponseTimeFilterPostcodeSectorProperties
                switch Decoders.decodeOptional(clazz: ResponseTravelTimeStatistics.self, source: sourceDictionary["travel_time_reachable"] as AnyObject?) {
                
                case let .success(value): _result.travelTimeReachable = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTravelTimeStatistics.self, source: sourceDictionary["travel_time_all"] as AnyObject?) {
                
                case let .success(value): _result.travelTimeAll = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["coverage"] as AnyObject?) {
                
                case let .success(value): _result.coverage = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeSectorProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeSectors]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeSectors].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeSectors]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeSectors].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeSectors
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeSectors.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeSectors> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeSectors() : instance as! ResponseTimeFilterPostcodeSectors
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterPostcodeSectorsResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeSectors", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodeSectorsResult]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodeSectorsResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodeSectorsResult]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodeSectorsResult].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodeSectorsResult
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodeSectorsResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodeSectorsResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodeSectorsResult() : instance as! ResponseTimeFilterPostcodeSectorsResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterPostcodeSector].self, source: sourceDictionary["sectors"] as AnyObject?) {
                
                case let .success(value): _result.sectors = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodeSectorsResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodes]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodes].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodes]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodes].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodes
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodes.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodes> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodes() : instance as! ResponseTimeFilterPostcodes
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterPostcodesResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodes", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodesProperties]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodesProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodesProperties]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodesProperties].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodesProperties
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodesProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodesProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodesProperties() : instance as! ResponseTimeFilterPostcodesProperties
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["distance"] as AnyObject?) {
                
                case let .success(value): _result.distance = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodesProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterPostcodesResult]
        Decoders.addDecoder(clazz: [ResponseTimeFilterPostcodesResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterPostcodesResult]> in
            return Decoders.decode(clazz: [ResponseTimeFilterPostcodesResult].self, source: source)
        }

        // Decoder for ResponseTimeFilterPostcodesResult
        Decoders.addDecoder(clazz: ResponseTimeFilterPostcodesResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterPostcodesResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterPostcodesResult() : instance as! ResponseTimeFilterPostcodesResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterPostcode].self, source: sourceDictionary["postcodes"] as AnyObject?) {
                
                case let .success(value): _result.postcodes = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterPostcodesResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterProperties]
        Decoders.addDecoder(clazz: [ResponseTimeFilterProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterProperties]> in
            return Decoders.decode(clazz: [ResponseTimeFilterProperties].self, source: source)
        }

        // Decoder for ResponseTimeFilterProperties
        Decoders.addDecoder(clazz: ResponseTimeFilterProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterProperties() : instance as! ResponseTimeFilterProperties
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["travel_time"] as AnyObject?) {
                
                case let .success(value): _result.travelTime = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["distance"] as AnyObject?) {
                
                case let .success(value): _result.distance = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseDistanceBreakdownItem].self, source: sourceDictionary["distance_breakdown"] as AnyObject?) {
                
                case let .success(value): _result.distanceBreakdown = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseFares.self, source: sourceDictionary["fares"] as AnyObject?) {
                
                case let .success(value): _result.fares = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseRoute.self, source: sourceDictionary["route"] as AnyObject?) {
                
                case let .success(value): _result.route = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeFilterResult]
        Decoders.addDecoder(clazz: [ResponseTimeFilterResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeFilterResult]> in
            return Decoders.decode(clazz: [ResponseTimeFilterResult].self, source: source)
        }

        // Decoder for ResponseTimeFilterResult
        Decoders.addDecoder(clazz: ResponseTimeFilterResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeFilterResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeFilterResult() : instance as! ResponseTimeFilterResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseTimeFilterLocation].self, source: sourceDictionary["locations"] as AnyObject?) {
                
                case let .success(value): _result.locations = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["unreachable"] as AnyObject?) {
                
                case let .success(value): _result.unreachable = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeFilterResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMap]
        Decoders.addDecoder(clazz: [ResponseTimeMap].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMap]> in
            return Decoders.decode(clazz: [ResponseTimeMap].self, source: source)
        }

        // Decoder for ResponseTimeMap
        Decoders.addDecoder(clazz: ResponseTimeMap.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMap> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMap() : instance as! ResponseTimeMap
                switch Decoders.decodeOptional(clazz: [ResponseTimeMapResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMap", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMapBoundingBoxes]
        Decoders.addDecoder(clazz: [ResponseTimeMapBoundingBoxes].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMapBoundingBoxes]> in
            return Decoders.decode(clazz: [ResponseTimeMapBoundingBoxes].self, source: source)
        }

        // Decoder for ResponseTimeMapBoundingBoxes
        Decoders.addDecoder(clazz: ResponseTimeMapBoundingBoxes.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMapBoundingBoxes> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMapBoundingBoxes() : instance as! ResponseTimeMapBoundingBoxes
                switch Decoders.decodeOptional(clazz: [ResponseTimeMapBoundingBoxesResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMapBoundingBoxes", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMapBoundingBoxesResult]
        Decoders.addDecoder(clazz: [ResponseTimeMapBoundingBoxesResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMapBoundingBoxesResult]> in
            return Decoders.decode(clazz: [ResponseTimeMapBoundingBoxesResult].self, source: source)
        }

        // Decoder for ResponseTimeMapBoundingBoxesResult
        Decoders.addDecoder(clazz: ResponseTimeMapBoundingBoxesResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMapBoundingBoxesResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMapBoundingBoxesResult() : instance as! ResponseTimeMapBoundingBoxesResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseBoundingBox].self, source: sourceDictionary["bounding_boxes"] as AnyObject?) {
                
                case let .success(value): _result.boundingBoxes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTimeMapProperties.self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMapBoundingBoxesResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMapProperties]
        Decoders.addDecoder(clazz: [ResponseTimeMapProperties].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMapProperties]> in
            return Decoders.decode(clazz: [ResponseTimeMapProperties].self, source: source)
        }

        // Decoder for ResponseTimeMapProperties
        Decoders.addDecoder(clazz: ResponseTimeMapProperties.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMapProperties> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMapProperties() : instance as! ResponseTimeMapProperties
                switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["is_only_walking"] as AnyObject?) {
                
                case let .success(value): _result.isOnlyWalking = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMapProperties", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMapResult]
        Decoders.addDecoder(clazz: [ResponseTimeMapResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMapResult]> in
            return Decoders.decode(clazz: [ResponseTimeMapResult].self, source: source)
        }

        // Decoder for ResponseTimeMapResult
        Decoders.addDecoder(clazz: ResponseTimeMapResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMapResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMapResult() : instance as! ResponseTimeMapResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: [ResponseShape].self, source: sourceDictionary["shapes"] as AnyObject?) {
                
                case let .success(value): _result.shapes = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTimeMapProperties.self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMapResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMapWkt]
        Decoders.addDecoder(clazz: [ResponseTimeMapWkt].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMapWkt]> in
            return Decoders.decode(clazz: [ResponseTimeMapWkt].self, source: source)
        }

        // Decoder for ResponseTimeMapWkt
        Decoders.addDecoder(clazz: ResponseTimeMapWkt.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMapWkt> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMapWkt() : instance as! ResponseTimeMapWkt
                switch Decoders.decodeOptional(clazz: [ResponseTimeMapWktResult].self, source: sourceDictionary["results"] as AnyObject?) {
                
                case let .success(value): _result.results = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMapWkt", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTimeMapWktResult]
        Decoders.addDecoder(clazz: [ResponseTimeMapWktResult].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTimeMapWktResult]> in
            return Decoders.decode(clazz: [ResponseTimeMapWktResult].self, source: source)
        }

        // Decoder for ResponseTimeMapWktResult
        Decoders.addDecoder(clazz: ResponseTimeMapWktResult.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTimeMapWktResult> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTimeMapWktResult() : instance as! ResponseTimeMapWktResult
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["search_id"] as AnyObject?) {
                
                case let .success(value): _result.searchId = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["shape"] as AnyObject?) {
                
                case let .success(value): _result.shape = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: ResponseTimeMapProperties.self, source: sourceDictionary["properties"] as AnyObject?) {
                
                case let .success(value): _result.properties = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTimeMapWktResult", actual: "\(source)"))
            }
        }
        // Decoder for [ResponseTransportationMode]
        Decoders.addDecoder(clazz: [ResponseTransportationMode].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTransportationMode]> in
            return Decoders.decode(clazz: [ResponseTransportationMode].self, source: source)
        }

        // Decoder for ResponseTransportationMode
        Decoders.addDecoder(clazz: ResponseTransportationMode.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTransportationMode> in
            //TODO: I don't think we need this anymore
            return Decoders.decode(clazz: ResponseTransportationMode.self, source: source, instance: instance)
        }
        // Decoder for [ResponseTravelTimeStatistics]
        Decoders.addDecoder(clazz: [ResponseTravelTimeStatistics].self) { (source: AnyObject, instance: AnyObject?) -> Decoded<[ResponseTravelTimeStatistics]> in
            return Decoders.decode(clazz: [ResponseTravelTimeStatistics].self, source: source)
        }

        // Decoder for ResponseTravelTimeStatistics
        Decoders.addDecoder(clazz: ResponseTravelTimeStatistics.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ResponseTravelTimeStatistics> in
            if let sourceDictionary = source as? [AnyHashable: Any] {
                let _result = instance == nil ? ResponseTravelTimeStatistics() : instance as! ResponseTravelTimeStatistics
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["min"] as AnyObject?) {
                
                case let .success(value): _result.min = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["max"] as AnyObject?) {
                
                case let .success(value): _result.max = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["mean"] as AnyObject?) {
                
                case let .success(value): _result.mean = value
                case let .failure(error): break
                
                }
                switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["median"] as AnyObject?) {
                
                case let .success(value): _result.median = value
                case let .failure(error): break
                
                }
                return .success(_result)
            } else {
                return .failure(.typeMismatch(expected: "ResponseTravelTimeStatistics", actual: "\(source)"))
            }
        }
    }()

    static fileprivate func initialize() {
        _ = Decoders.__once
    }
}
